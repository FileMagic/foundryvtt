<p>The <code>DataModel</code> class provided as <code>foundry.abstract.DataModel</code> is a powerful tool for defining data schema and functionality that is used throughout Foundry Virtual Tabletop. For an overview of this concept please read the introductory article about the <a href="/article/v10-data-model/" target="_blank">Version 10 Data Model</a> which was written when this architecture was first added to Foundry Virtual Tabletop.</p>

<p>Data Models are not solely for use by core Document types, but also empower system developers to define such Data Models in order to represent data specific to their systems. Data Models defined in this way receive many of the same benefits as their core API counterparts, including validation on initialization and update, and on-the-fly data migration and coercion. It also allows functionality to be delegated out to these models, reducing the burden on the system's Document implementation to solely house such logic.</p>

<p>This article focuses on how to utilize Data Models for a Game System in Foundry Virtual Tabletop. For more detailed information on Data Models themselves please read the above article or refer to the @API[classes/foundry.abstract.DataModel,DataModel] API Documentation.</p>

<h2 id="definition" class="border">Defining a Data Model</h2>
<p>Data Models themselves are lightweight classes that can be defined very simply. Here we will take an example system template and construct a corresponding Data Model for it.</p>

<h4>Data Model</h4>
<pre><code class="lang-js">class CharacterData extends foundry.abstract.DataModel {
  static defineSchema() {
    const fields = foundry.data.fields;
    return {
      biography: new fields.HTMLField(),
      health: new fields.SchemaField({
        value: new fields.NumberField({
          required: true,
          initial: 10,
          integer: true
        }),
        min: new fields.NumberField({
          required: true,
          initial: 0,
          integer: true
        }),
        max: new fields.NumberField({
          required: true,
          initial: 10,
          integer: true
        })
      }),
      proficiencies: new fields.SchemaField({
        weapons: new fields.ArrayField(new fields.StringField()),
        skills: new fields.ArrayField(new fields.StringField())
      })
    };
  }
}</code></pre>

<p class="note info">If developing for <strong>Version 10</strong>, you may wish to include the <code>static _enableV10Validation = true;</code> property on your DataModel class which enables more strict validation of your defined model fields. If developing for Version 11 or later this property is unnecessary.</p>

<p>With the full schema of your DataModel defined, it becomes unnecessary to define the schema using the <code>template.json</code> file. The only fields necessary in that file are to confirm the document types that your system uses, and which fields require additional server-side sanitization as <code>htmlFields</code>, for example:</p>

  <h4>template.json</h4>
  <pre><code class="lang-json">{
  "Actor": {
    "types": ["character"],
    "htmlFields": ["biography"],
    "character": {}
  }
}</code></pre>

<h2 id="registration" class="border">Registering a Data Model</h2>
<p>Once the Data Model is defined, the core API can be made aware of it and will automatically apply the data model to the <code>system</code> field of any registered types.</p>

<p>The following code snippet will register the example <code>CharacterData</code> model to be automatically applied as the <code>system</code> data for every Actor of the <code>character</code> type.</p>
<pre><code class="lang-js">Hooks.on("init", () => {
  CONFIG.Actor.systemDataModels.character = CharacterData;
});</code></pre>

<h2 id="migration" class="border">Migrations</h2>
<p>Migrations and data coercion can be performed before your Data Model is instantiated, allowing legacy data to be converted into a format that the current version of your system understands. Migrations are run when the source data is first retrieved from disk, as well as run on any update deltas before they are applied to the Document.</p>
<pre><code class="lang-js">class CharacterData extends foundry.abstract.DataModel {
  static defineSchema() {
    // Omitted for brevity.
  }

  /**
   * Migrate source data from some prior format into a new specification.
   * The source parameter is either original data retrieved from disk or provided by an update operation.
   * @inheritDoc
   */
  static migrateData(source) {
    if ( "weapons" in source ) {
      source.weapons = source.weapons.map(weapon => {
        return weapon === "bmr" ? "boomerang" : weapon;
      });
    }
    return super.migrateData(source);
  }
}</code></pre>

<h2 id="enhancement" class="border">Enhancing a Data Model</h2>
<p>Data Models can have methods added to them that encapsulate logic relevant to the particular system-specific type of Document that they represent. This allows you to move logic out of the Document implementation and house it in a location that is much more specific to its functionality. The parent Document instance is accessible from within the Data Model's instance methods via <code>this.parent</code>, allowing for more complex interactions and logic.</p>
<pre><code class="lang-js">class CharacterData extends foundry.abstract.DataModel {
  static defineSchema() {
    // Omitted for brevity.
  }

  static migrateData() {
    // Omitted for brevity.
  }

  /**
   * Determine whether the character is dead.
   * @type {boolean}
   */
  get dead() {
    const invulnerable = CONFIG.specialStatusEffects.INVULNERABLE;
    if ( this.parent.effects.some(e => e.statuses.has("invulnerable") ) return false;
    return this.health.value &lt;= this.health.min;
  }
}</code></pre>
<p>The defined <code>dead</code> property could then be accessed on any Actor document of the character type as follows:</p>
<pre><code class="lang-js">// Determine if a character is dead.
game.actors.getName("Character").system.dead;
</code></pre>
